<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>PathFinder</title>
  <script type="text/javascript" src="map.js"></script>
  <style>
    html, body {
        padding: 0;
        margin: 0;
        height: 100%;
        width: 100%;
    }

    body {
        display: flex;
        align-items: center;
        justify-content: center;
    }

    #app {
        background-color: #c5c7c9;
        width: 85vh;
        height: 85vh;
        display: flex;
        flex-wrap: wrap;
    }
    #export-button {
        position: absolute;
        right: 50px;
        bottom: 50px
    }
    .cell {
        width: 2%;
        height: 2%;
    }
    .inner-cell {
        /*border-right: 1px solid lightblue;*/
        /*border-bottom: 1px solid lightblue;*/
        width: 100%;
        height: 100%;
    }
    .inner-cell.right-most {
        border-right: none;
    }
    .inner-cell.bottom-most {
        border-bottom: none;
    }
    .start {
        background-color: limegreen;
    }
    .end {
        background-color: red;
    }
    .wall {
        background-color: black;
    }
    .visited {
        background-color: yellow;
    }
    .path {
        background-color: orangered;
    }
  </style>
</head>
<body>
  <div id="app"></div>
  <button id="export-button">Export</button>
  <script>
    const app = document.getElementById('app')
    const exportButton = document.getElementById('export-button')
    const WIDTH = 50;
    const HEIGHT  = 50;
    const start = [0, 0]
    const end = [WIDTH - 1, HEIGHT - 1]

    class Cell {
      constructor (x, y) {
        const bottomMost = y === HEIGHT - 1
        const rightMost = x === WIDTH - 1

        this.y = y;
        this.x = x;
        this.el = document.createElement('div')
        this.el.classList.add('cell')
        this.el.title = `${x}-${y}`
        this.innerEl = document.createElement('div')
        this.innerEl.classList.add('inner-cell')
        if (rightMost) {
          this.innerEl.classList.add('right-most')
        }
        if (bottomMost) {
          this.innerEl.classList.add('bottom-most')
        }
        this.el.append(this.innerEl)

        app.append(this.el)
      }

      convertToStart () {
        this.el.classList.add('start')
        this.start = true
        this.weight = 0
      }

      convertToEnd () {
        this.el.classList.add('end')
        this.end = true
      }

      convertToWall () {
        this.el.classList.toggle('wall')
        this.wall = !this.wall
      }

      setVisited () {
        this.visited = true
        this.el.classList.add('visited')
      }

      drawPath () {
        this.el.classList.add('path')
      }

      addEventListener (eventListener) {
        this.el.onclick = () => eventListener(this)
      }

      calculateRemaining () {
        this.remaining = Math.abs(end[0] - this.x) + Math.abs(end[1] - this.y)
        return this.remaining
      }

      calculateA (parent) {
        this.setVisited()
        this.parent = parent
        this.weight = parent.weight + 1
        this.Avalue = this.weight + this.calculateRemaining()
        return this.Avalue
      }

      findValidNeighbours () {
        const neighbours = [
          cells[this.x - 1]?.[this.y],
          cells[this.x + 1]?.[this.y],
          cells[this.x]?.[this.y - 1],
          cells[this.x]?.[this.y + 1]
        ].filter(cell => {
          return cell && !cell.wall && !cell.visited
        })
        return neighbours
      }
    }

    class SortedStack {
      constructor () {
        this.stack = []
      }
      push (el, value) {
        if (this.stack.length === 0) {
          this.stack.push({ el, value })
        } else {
          let i = 0
          while (this.stack[i]?.value < value) {
            i++
          }
          this.stack.splice(i, 0, { el, value })
        }
      }
      pop () {
        return this.stack.pop()?.el
      }
    }

    const cells = {}
    let cellsItt
    let searchStack = new SortedStack()

    function populate () {
      for (let height = 0; height < WIDTH; height++) {
        for (let width = 0; width < HEIGHT; width++) {
          cells[width] = cells[width] ? cells[width] : {}
          cells[width][height] = new Cell(width, height)
        }
      }

      cellsItt = Object.values(cells).reduce((cellsArr, cell) => {
        cellsArr.push(...Object.values(cell))
        return cellsArr
      }, [])
    }

    function defineEnds (start, end) {
      cells[start[0]][start[1]].convertToStart()
      cells[end[0]][end[1]].convertToEnd()
    }

    function convertToWall (cell) {
      cell.convertToWall()
    }

    function enableWallMaker () {
      cellsItt.forEach(cell => {
        cell.addEventListener(convertToWall)
      })
    }

    function fillWalls (map) {
      map.forEach(wall => cells[wall[0]][wall[1]].convertToWall())
    }

    function findPath(method = 'A') {
      let curr = cells[start[0]][start[1]]
      const endCell = cells[end[0]][end[1]]
      let i = 0
      while (curr && curr !== endCell && i < 2500) {
        i++
        const neighbours = curr.findValidNeighbours()
        neighbours.forEach(cell => {
          searchStack.push(cell, cell.calculateA(curr))
        })
        curr = searchStack.pop()
      }
    }

    function drawPath() {
      let curr = cells[end[0]][end[1]]
      let i = 0
      while (curr && i < 2500) {
        i++
        curr.drawPath()
        curr = curr.parent
      }
    }

    function copyText (value) {
      const mockInput = document.createElement('input')
      mockInput.style = 'position: absolute; left: -1000px; top: -1000px;'
      mockInput.value = value
      document.body.appendChild(mockInput)
      mockInput.select()
      document.execCommand('copy')
      document.body.removeChild(mockInput)

      // app.appendChild(mockInput)
    }

    populate()
    defineEnds(start, end)
    fillWalls(map)
    enableWallMaker()
    exportButton.onclick = () => {
      copyText(JSON.stringify(cellsItt.filter(cell => cell.wall).map(cell => [cell.x, cell.y])))
      cellsItt.forEach(cell => {
        cell.addEventListener(() => {})
      })
      findPath()
      drawPath()
    }


  </script>
</body>
</html>
